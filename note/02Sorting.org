#+TITLE: Sorting

* DONE 21Elementary-Sorts
  CLOSED: [2017-01-12 Thu 21:15]
  - State "DONE"       from "TODO"       [2017-01-12 Thu 21:15]
** Rules of the game

+ Sorting problem.
  - Ex. Student records in a university.
  - Sort. Rearrange array of N items into ascending order.

+ Sample sort client.
  - Goal: Sort any type of data.
  - Sort random real numbers in ascending order: CODE
  - Sort strings from file in alphabetical order: CODE
  - Sort the files in a given directory by filename: CODE

+ Callbacks.
  - Goal: Sort any type of data.
  - Callback = reference to executable code.
    + Client passes array of objects to sort() function.
    + The sort() function calls back object's compareTo() method as needed.
  - Implementing callbacks.

+ Total order.
  - A total order a binary relation ≤ that satisfies:
    + Antisymmetry: if v ≤ w and w ≤ v, then v = w.
    + Transitivity: if v ≤ w and w ≤ x, then v ≤ x.
    + Totality: either v ≤ w or w ≤ v or both.
  - Surprising but true: The <= operator for double is not a total order. (!)

+ Comparable API.
  - Implement compareTo() so that v.compareTo(w).
    + Is a total order.
    + Returns a negative integer, zero, or positive integer if v is less than,
      equal to, or greater than w, respectively.
    + Throws an exception if incompatible types (or either is null).
  - Built-in comparable types. Integer, Double, String, Date, File, ...
  - User-defined comparable types. Implement the Comparable interface.

+ Implementing the Comparable interface
  - Date data type: CODE

+ Two useful sorting abstractions.
  - Helper functions: Refer to data through compares and exchanges.
  - Less: Is item v less than w?
  - Exchange: Swap item in array a[] at index i with the one at index j.

+ Testing.
  - Goal. Test if an array is sorted.
  - Q: If the sorting algorithm passes the test, did it correctly sort the
    array? 
  - A: Yes. If only use the less and exch function.

** Selection sort

+ Selection sort demo.
  - In iteration i, find index min of smallest remaining entry.
  - Swap a[i] and a[min].

+ Selection sort.
  - Algorithm. ↑ scans from left to right.
  - Invariants.
    + Entries the left of ↑ (including ↑) fixed and in ascending order.
    + No entry to right of ↑ is smaller than any entry to the left of ↑.

+ Selection sort inner loop.
  - To maintain algorithm invariants:
    + Move the pointer to the right.
    + Identify index of minimum entry on right.
    + Exchange into position.

+ Selection sort: Java implementation: CODE

+ Selection sort: mathematical analysis.
  - Proposition: Selection sort uses (N–1) + (N–2) + ... + 1 + 0 ~ N^2 / 2
    compares and N exchanges.
  - PICTURE
  - Running time insensitive to input. Quadratic time, even if input is sorted.
  - Data movement is minimal. Linear number of exchanges.
  - ANIMATIONS

** Insertion sort

+ Insertion sort demo
  - In iteration i, swap a[i] with each larger entry to its left.

+ Insertion sort
  - Algorithm. ↑ scans from left to right.
  - Invariants.
    + Entries to the left of ↑ (including ↑) are in ascending order.
    + Entries to the right of ↑ have not yet been seen.

+ Insertion sort inner loop.
  - To maintain algorithm invariants:
    + Move the pointer to the right.
    + Moving from right to left, exchange a[i] with each larger entry to its
      left.

+ Insertion sort: Java implementation: CODE

+ Insertion sort: mathematical analysis.
  - Proposition. To sort a randomly-ordered array with distinct keys, insertion
    sort uses ~ 1⁄4 N^2 compares and ~ 1⁄4 N^2 exchanges on average.
  - Pf. Expect each entry to move halfway back
  - PICTURE
  - ANIMATION

+ Insertion sort: best and worst case.
  - Best case. If the array is in ascending order, insertion sort makes N - 1
    compares and 0 exchanges.
  - Worst case. If the array is in descending order (and no duplicates),
    insertion sort makes ~ 1⁄2 N^2 compares and ~ 1⁄2 N^2 exchanges.

+ Insertion sort: partially-sorted arrays.
  - Def: An inversion is a pair of keys that are out of order.
  - Def: An array is partially sorted if the number of inversions is ≤ c N.
    + Ex 1. A subarray of size 10 appended to a sorted subarray of size N.
    + Ex 2. An array of size N with only 10 entries out of place.

+ Proposition: For partially-sorted arrays, insertion sort runs in linear time.
  Pf. Number of exchanges equals the number of inversions.

** Shell sort

+ Shellsort overview.
  - Idea: Move entries more than one position at a time by h-sorting the array.
  - Shellsort: [Shell 1959] h-sort array for decreasing sequence of values
    of h.

+ h-sorting
  - How to h-sort an array? Insertion sort, with stride length h. 
  - Why insertion sort?
    + Big increments => small subarray.
    + Small increments => nearly in order. [stay tuned]

+ Shellsort example: increments 7, 3, 1. PICTURE

+ Shellsort: intuition.
  - Proposition: A g-sorted array remains g-sorted after h-sorting it.
  - Challenge: Prove this fact—it's more subtle than you'd think!

+ Shellsort: which increment sequence to use?
  - Powers of two. 1, 2, 4, 8, 16, 32, ... 
    + No.
  - Powers of two minus one. 1, 3, 7, 15, 31, 63, ... 
    + Maybe.
  - 3x + 1. 1, 4, 13, 40, 121, 364, ... 
    + OK. Easy to compute.
  - Sedgewick. 1, 5, 19, 41, 109, 209, 505, 929, 2161, 3905, ... 
    + Good. Tough to beat in empirical studies.

+ Shellsort: Java implementation. CODE
+ Shellsort: visual trace.
+ Shellsort: animation.

+ Shellsort: analysis.
  - Proposition. The worst-case number of compares used by shellsort with the
    3x+1 increments is O(N ^ (3/2)).
  - Remark. Accurate model has not yet been discovered (!)

+ Why are we interested in shellsort?
  - Example of simple idea leading to substantial performance gains.
  - Useful in practice.
  - Simple algorithm, nontrivial performance, interesting questions
  - Lesson: Some good algorithms are still waiting discovery.
    
** Shuffling

+ How to shuffle an array.
  - Goal: Rearrange array so that result is a uniformly random permutation.
    
+ Shuffle sort.
  - Generate a random real number for each array entry.
  - Sort the array.
  - Proposition: Shuffle sort produces a uniformly random permutation of the
    input array, provided no duplicate values.

+ Knuth shuffle demo.
  - In iteration i, pick integer r between 0 and i uniformly at random.
  - Swap a[i] and a[r].
  - Proposition: [Fisher-Yates 1938] Knuth shuffling algorithm produces a
    uniformly random permutation of the input array in linear time.
  - Java implementation: CODE

+ War story (online poker).
  - Bug 1. Random number r never 52 ⇒ 52nd card can't end up in 52nd place.
  - Bug 2. Shuffle not uniform (should be between 1 and i).
  - Bug 3. random() uses 32-bit seed ⇒ 232 possible shuffles.
  - Bug 4. Seed = milliseconds since midnight ⇒ 86.4 million shuffles.
  - Bottom line. Shuffling a deck of cards is hard!

** Convex hull

+ The convex hull of a set of N points is the smallest perimeter fence
  enclosing the points.
+ Convex hull output: Sequence of vertices in counterclockwise order.

+ Convex hull: mechanical algorithm
  - Hammer nails perpendicular to plane; stretch elastic rubber band around
    points.

+ Convex hull application: motion planning.
  - Robot motion planning: Find shortest path in the plane from s to t that
    avoids a polygonal obstacle.
  - Fact: Shortest path is either straight line from s to t or it is one of two
    polygonal chains of convex hull.

+ Convex hull application: farthest pair.
  - Farthest pair problem: Given N points in the plane, find a pair of points
    with the largest Euclidean distance between them.
  - Fact: Farthest pair of points are extreme points on convex hull.

+ Convex hull: geometric properties.
  - Fact: Can traverse the convex hull by making only counterclockwise turns.
  - Fact: The vertices of convex hull appear in increasing order of polar angle
    with respect to point p with lowest y-coordinate. 

+ Graham scan demo.
  - Choose point p with smallest y-coordinate.
  - Sort points by polar angle with p.
  - Consider points in order; discard unless it create a ccw turn.

+ Graham scan: implementation challenges.
  - Q. How to find point p with smallest y-coordinate?
  - A. Define a total order, comparing by y-coordinate. [next lecture]
  - Q. How to sort points by polar angle with respect to p ? 
  - A. Define a total order for each point p. [next lecture]
  - Q. How to determine whether p1 → p2 → p3 is a counterclockwise turn? 
  - A. Computational geometry. [next two slides]
  - Q. How to sort efficiently?
  - A. Mergesort sorts in N log N time. [next lecture]
  - Q. How to handle degeneracies (three or more points on a line)? 
  - A. Requires some care, but not hard. [see booksite]

+ Implementing ccw.
  - CCW: Given three points a, b, and c, is a → b → c a counterclockwise
    turn?
  - Determinant (or cross product) gives 2x signed area of planar triangle.
    + 2 * Area(a, b, c) = (bx −ax)(cy −ay) − (by −ay)(cx −ax)
    + If signed area > 0, then a → b → c is counterclockwise.
    + If signed area < 0, then a → b → c is clockwise.
    + If signed area = 0, then a → b → c are collinear.

+ Graham scan: implementation. CODE
* DONE 22Mergesort
  CLOSED: [2017-01-15 Sun 21:24]
  - State "DONE"       from "TODO"       [2017-01-15 Sun 21:24]
** [Two classic sorting algorithms]

+ Critical components in the world’s computational infrastructure.
  - Mergesort.
  - Quicksort.

** Mergesort

+ Basic plan.
  - Divide array into two halves.
  - Recursively sort each half.
  - Merge two halves.

+ Abstract in-place merge demo.
  - Goal: Given two sorted subarrays a[lo] to a[mid] and a[mid+1] to a[hi],
    replace with sorted subarray a[lo] to a[hi].
  - Java implementation: CODE

+ Assertions.
  
+ Mergesort.
  - Java implementation: CODE
  - Trace: PICTURE
  - ANIMATION

+ Mergesort: number of compares and array accesses.
  - Proposition: Mergesort uses at most N lg N compares and 6 N lg N array
    accesses to sort any array of size N.
  - Pf sketch: The number of compares C (N) and array accesses A (N) to
    mergesort an array of size N satisfy the recurrences:
    + C (N) ≤ C ([N / 2]) + C ([N / 2]) + N for N > 1, with C (1) = 0.
    + A (N) ≤ A ([N / 2]) + A ([N / 2]) + 6 N for N > 1, with A (1) = 0.
    + Divide-and-conquer recurrence: proof by picture.
    + Divide-and-conquer recurrence: proof by expansion.
    + Divide-and-conquer recurrence: proof by induction.

+ Mergesort analysis: memory.
  - Proposition: Mergesort uses extra space proportional to N.
  - Pf: The array aux[] needs to be of size N for the last merge.
  - Def: A sorting algorithm is in-place if it uses ≤ c log N extra memory. 
  - Ex: Insertion sort, selection sort, shellsort.
  - Challenge for the bored. In-place merge. [Kronrod, 1969]

+ Mergesort: practical improvements.
  - Use insertion sort for small subarrays.
    + Mergesort has too much overhead for tiny subarrays.
    + Cutoff to insertion sort for ≈ 7 items.
  - Stop if already sorted.
    + Is biggest item in first half ≤ smallest item in second half? 
    + Helps for partially-ordered arrays.
  - Eliminate the copy to the auxiliary array: Save time (but not space) by
    switching the role of the input and auxiliary array in each recursive call.  

+ Mergesort: visualization: PICTURE

** Bottom-up mergesort

+ Basic plan.
  - Pass through array, merging subarrays of size 1.
  - Repeat for subarrays of size 2, 4, 8, 16...

+ Bottom-up mergesort: Java implementation: CODE
+ Bottom-up mergesort: visual trace: PICTURE

** Sorting complexity

+ Complexity of sorting.
  - Computational complexity: Framework to study efficiency of algorithms for
    solving a particular problem X. 
  - Model of computation: Allowable operations.
  - Cost model: Operation count(s).
  - Upper bound: Cost guarantee provided by some algorithm for X
  - Lower bound: Proven limit on cost guarantee of all algorithms for X.
    Optimal algorithm. Algorithm with best possible cost guarantee for X.

+ Example: sorting.
  - Model of computation: decision tree. ・
  - Cost model: # compares.
  - Upper bound: ~ N lg N from mergesort.
  - Lower bound: ~ N lg N.
    + Proposition: Any compare-based sorting algorithm must use at least lg ( N
      ! ) ~ N lg N compares in the worst-case. 
    + Pf.
  - Optimal algorithm = mergesort.

+ Complexity results in context.
  - Compares? Mergesort is optimal with respect to number compares.
  - Space? Mergesort is not optimal with respect to space usage.
  - Lessons. Use theory as a guide.
    + Ex. Design sorting algorithm that guarantees 1⁄2 N lg N compares? 
    + Ex. Design sorting algorithm that is both time- and space-optimal?
  - Lower bound may not hold if the algorithm has information about: 
    + The initial order of the input: Partially-ordered arrays. insertion sort
      requires only N-1 compares if input array is sorted
    + The distribution of key values: Duplicate keys. stay tuned for 3-way
      quicksort
    + The representation of the keys: Digital properties of keys. stay tuned
      for radix sorts

** Comparators

+ Goal:
  - Sort music library by artist name.
  - Sort music library by song name.

+ Comparator interface.
  - Comparable interface: sort using a type's natural order.
  - Comparator interface: sort using an alternate order.
    + Required property. Must be a total order.
      
+ Comparator interface: system sort.
  - To use with Java system sort:
    + Create Comparator object.
    + Pass as second argument to Arrays.sort().
  - Bottom line: Decouples the definition of the data type from the definition
    of what it means to compare two objects of that type.

+ Comparator interface: using with our sorting libraries.
  - To support comparators in our sort implementations:
    + Use Object instead of Comparable.
    + Pass Comparator to sort() and less() and use it in less().
  - CODE.

+ Comparator interface: implementing.
  - To implement a comparator:
    + Define a (nested) class that implements the Comparator interface.
    + Implement the compare() method.
  - CODE.

+ Polar order.
  - Polar order: Given a point p, order points by polar angle they make with p.
  - Application: Graham scan algorithm for convex hull.
  - High-school trig solution: Compute polar angle θ w.r.t. p using atan2().
    + Drawback: Evaluating a trigonometric function is expensive.
  - A ccw-based solution.
    + If q1 is above p and q2 is below p, then q1 makes smaller polar angle.
    + If q1 is below p and q2 is above p, then q1 makes larger polar angle.
    + Otherwise, ccw(p, q1, p2) identifies which of q1 or q2 makes large angle.
  - Comparator interface: polar order. CODE

** Stability

+ Stability
  - A stable sort preserves the relative order of items with equal keys.
  - Q. Which sorts are stable?
  - A. Insertion sort and mergesort (but not selection sort or shellsort).
  - Note: Need to carefully check code ("less than" vs. "less than or equal
    to").

+ Stability
  - Proposition. Insertion sort is stable.
    + Pf. Equal items never move past each other.
  - Proposition. Selection sort is not stable.
    + Pf by counterexample. Long-distance exchange might move an item past some
      equal item.
  - Proposition. Shellsort sort is not stable.
    + Pf by counterexample. Long-distance exchanges.
  - Proposition. Mergesort is stable.
    + Pf. Suffices to verify that merge operation is stable.
    + Proposition. Merge operation is stable.
    + Pf. Takes from left subarray if equal keys.
